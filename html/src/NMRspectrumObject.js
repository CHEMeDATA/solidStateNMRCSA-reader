// AUTOMATIC IMPORT INSERTION WILL BE MADE HERE
// import statement in Mnova exportStatement.js
import { buildFromNMRspectrumObject } from "./mnovaJasonBuilder.js";

// import statements in Mnova importStatement.js
import { processMnovaJsonSpectrum } from "./mnovaJsonReader.js";
import { processMnovaJsonMolecule } from "./mnovaJsonReader.js";

import { extractSpectrumData } from "./mnovaJsonReader.js";
import { getRegionsWithSignal } from "./mnovaJsonReader.js";
import { filterOutPointsOutsideRegions } from "./mnovaJsonReader.js";
import { ingestMoleculeObject } from "./mnovaJsonReader.js";
import { ingestSpectrumRegions } from "./mnovaJsonReader.js";

import { processSf } from "./mnovaJsonReader.js";


import { ObjectBase } from "./objectBase.js";

export class NMRspectrumObject extends ObjectBase {
	constructor(param, input) {
		super(param, input, "NMRspectrumObject");
		// optionally override again
		this.verbose = 0;
	}

	_handleLoadDemoData(demoParam) {
		this._loadDemoData(demoParam);
	}

	_loadDemoData(demoParam = {}) {
		const spectralData = {
			pointNumber: 32768,
			larmor: 500,
			firstPoint: 11,
			lastPoint: -1.0,
			noiseLevel: 10,
			...demoParam.spectralData, // override defaults if present
		};

		const arrayLorentzian = {
			centers: [7.27],
			widthsInHz: [0.7],
			amplitudes: [1],
			...demoParam.arrayLorentzian, // override defaults if present
		};

		const values = [];
		const mean = 0;

		for (let i = 0; i < spectralData.pointNumber; i++) {
			let u = 0;
			while (u === 0) u = Math.random();
			const v = Math.random();
			const amplitude = Math.sqrt(-2.0 * Math.log(u));
			const realPart = amplitude * Math.cos(2.0 * Math.PI * v);
			//const complexPart = amplitude * Math.sin(2.0 * Math.PI * v);
			values.push(realPart * spectralData.noiseLevel + mean);
		}
		function lorentzian(arrayLorentzian, larmor, x, i) {
			const id_centers = i < arrayLorentzian.centers.length ? i : arrayLorentzian.centers.length - 1; // should be useless (should not loop beyond i)
			const id_widthsInHz = i < arrayLorentzian.widthsInHz.length ? i : arrayLorentzian.widthsInHz.length - 1; // will often be exploited to avoid repeating if constant
			const id_amplitudes = i < arrayLorentzian.amplitudes.length ? i : arrayLorentzian.amplitudes.length -1; // may be exploited to avoid repeating if constant
			const center = arrayLorentzian.centers[id_centers];
			const dx = x - center;
			const gamma = arrayLorentzian.widthsInHz[id_widthsInHz] / larmor;
			const amplitude = arrayLorentzian.amplitudes[id_amplitudes];
			return (
				amplitude /
				(Math.PI * gamma * (1 + (dx / gamma) ** 2))
			);
		}

		const increment =
			(spectralData.lastPoint - spectralData.firstPoint) /
			(spectralData.pointNumber - 1);
		for (let i = 0; i < arrayLorentzian.centers.length; i++) {
			for (let index = 0; index < values.length; index++) {
				const x = spectralData.firstPoint + increment * index;
				const larmor = spectralData.larmor;
				//values[index] += lorentzian(arrayLorentzian, larmor, x, i);
				// may replace this will fall to function 
				// values[index] += lorentzian(arrayLorentzian, larmor, x, i);
					//function lorentzian(arrayLorentzian, larmor, x, i) {
				const id_centers = i < arrayLorentzian.centers.length ? i : arrayLorentzian.centers.length - 1; // should be useless (should not loop beyond i)
				const id_amplitudes = i < arrayLorentzian.amplitudes.length ? i : arrayLorentzian.amplitudes.length -1; // may be exploited to avoid repeating if constant
				const id_widthsInHz = i < arrayLorentzian.widthsInHz.length ? i : arrayLorentzian.widthsInHz.length - 1; // will often be exploited to avoid repeating if constant
				const center = arrayLorentzian.centers[id_centers];
				const dx = x - center;
				const gamma = arrayLorentzian.widthsInHz[id_widthsInHz] / larmor;
				const amplitude = arrayLorentzian.amplitudes[id_amplitudes];
				values[index] += (
					amplitude /
					(Math.PI * gamma * (1 + (dx / gamma) ** 2))
				); // was returned
				//} closing function
			}
		}

		this.data = {
			values: values,
			firstPoint: spectralData.firstPoint,
			lastPoint: spectralData.lastPoint,
		};
	}

	// AUTOMATIC METHOD INSERTION WILL BE MADE HERE
//  export method // Should not minimize
 export_Editordjeanner_Version1_SourceMnovaJson_IDnone(param) {
	/* param:
	dataObj        : dataObj,
	objDataField   : dataObj.item.objDataField,
	creatorParam   : dataObj.creatorParam,
	targetObjType  : targetObjType,
	object         : dataObj.objSource
	objoutputFields
	*/
	const obj = this.data;
	const objDataField = param.objDataField;
	const objectObj = param.objectObj;
	const objSource = param.object;
	if (!objSource) {
		console.error(
			"No objSource string in param. Error generated by export_Editordjeanner_Version1_SourceMnovaJson_IDnone param : ",
			param
		);
		return {};
	}
	if (objSource === "nmrSpectrumObject") {
		if (objDataField.passedList[0] === "field1") {
			const oneSpectrum = buildFromNMRspectrumObject(objDataField, obj);
			const mnovaDataset = {
				$mnova_schema:
					"https://mestrelab.com/json-schemas/mnova/2023-07/01/nmr/dataset",
				spectra: [oneSpectrum],
			};

			return mnovaDataset;
		}
	}
  if (objSource === "setSpectra") {
		if (objDataField.passedList[0] === "field1") {
      var spectra = [];
      if (Array.isArray(obj.members)) {
        for (const member of obj.members) {
          const oneSpectrum = buildFromNMRspectrumObject(objDataField, member);
          spectra.push(oneSpectrum);
        }
      }
			const mnovaDataset = {
				$mnova_schema:
					"https://mestrelab.com/json-schemas/mnova/2023-07/01/nmr/dataset",
				spectra: spectra,
			};
			return mnovaDataset;
		}
	}

	if (objSource === "ZZZZZZZZ") {
		var retObj = {};
		var retObj = {};
		if (objDataField.passedList[0] === "field1") {
			retObj.dummy_data = 33;
			return retObj;
		}
		if (objDataField.passedList[0] === "field2") {
			retObj.dummy_data = 44;
			return retObj;
		}
		return retObj;
	}
	console.error(
		`objSource : ${objSource} not implemented from export_Editordjeanner_Version1_SourceMnovaJson_IDnone`
	);
	return {};
}

//  import method // Should not minimize
	import_Editordjeanner_Version1_SourceMnovaJson_IDnone(param, dataInput) {
		if (!dataInput.origin) {
			console.error("No origin data in dataInput for import", dataInput);
			this.data = {};
			// process.exit(1);
		}
		this.origin = dataInput.origin;
		this.conversionParameters = param;

		if (this.name == "NMRspectrumObject") {
			// Specify here the version number of the specific object (needed to allow version update)
			this.versionDataFromReader = 1;
			if (!dataInput.jsonSpectrum) {
				console.error("No jsonSpectrum in dataInput", dataInput);
				this.data = {};
				return;
			}
			const jsonSpectrum = dataInput.jsonSpectrum;
			const fieldsToKeepSpectrum = [
				"data",
				"raw_data",
				"multiplets",
				"peaks",
				"processing",
				"parameters",
				"$mnova_schema",
			];

			const allSpectraObjectsExtracted = processMnovaJsonSpectrum(
				jsonSpectrum,
				"spectra",
				fieldsToKeepSpectrum
			);

			if (typeof allSpectraObjectsExtracted === "undefined") {
				console.error("allSpectraObjectsExtracted", allSpectraObjectsExtracted);
				console.error("fileNameSpectrum", fileNameSpectrum);
			}

			if (this.verbose > 1) {
				var total = 0;
				for (var i = 0; i < allSpectraObjectsExtracted.length; i++) {
					total += allSpectraObjectsExtracted[i].length;
					if (this.verbose > 1)
						console.log(
							">>>>>>>>> ",
							" spectrum set ",
							i + 1,
							":",
							allSpectraObjectsExtracted[i].length,
							"spectra."
						);
				}
				if (this.verbose > 1)
					console.log(
						">>>>>>>>>>>>>>>>>>>>>>>>>> ",
						" total :",
						total,
						"spectra."
					);
			}

			var input = extractSpectrumData(allSpectraObjectsExtracted[0][0], "data");
			var larmor = input.larmor;
			if (param) {
				if (param.filterSpectra) {
					if (param.filterSpectra == "onlyFirst") {
						input = extractSpectrumData(
							allSpectraObjectsExtracted[0][0],
							"data"
						);
					}
					if (param.filterSpectra == "firstFirstLastOthers") {
						var index = 0;
						if (param.filterSpectraIndex) {
							index = param.filterSpectraIndex;
						}
						if (index == 0) {
							// first of first spectrum (experimental spectrum)
							input = extractSpectrumData(
								allSpectraObjectsExtracted[0][0],
								"data"
							);
						} else {
							// last (simulation) of other (non first)

							const redindex = index - 1;
							if (this.verbose > 1) console.log(" redindex :", redindex);
							if (redindex >= allSpectraObjectsExtracted.length) {
								this.data = {};
								return; // normal when not knowning until where go.
							}
							const lastItem = allSpectraObjectsExtracted[redindex].length - 1;
							input = extractSpectrumData(
								allSpectraObjectsExtracted[redindex][lastItem],
								"data"
							);
						}
					}
					if (param.filterSpectra == "any") {
						var index = 0;
						var index2 = 0;
						if (param.filterSpectraIndex) {
							index = param.filterSpectraIndex;
						}
						if (param.filterSpectraIndex2) {
							index2 = param.filterSpectraIndex2;
						}
						input = extractSpectrumData(
							allSpectraObjectsExtracted[index][index2],
							"data"
						);
					}
				}
			}
			// get min and max of chemShift (the scale)
			const extremas_chemshift = input.reduce(
				(acc, item) => {
					const value = item["chemShift"];
					if (typeof value === "number" && !isNaN(value)) {
						if (value < acc.min) acc.min = value;
						if (value > acc.max) acc.max = value;
					}
					return acc;
				},
				{ min: Infinity, max: -Infinity }
			);
			// get spectrum
			const values = input.map((d) => d.value);

			// create final data object
			this.data = {
				frequency: larmor,
				values: values,
				firstPoint: extremas_chemshift.max,
				lastPoint: extremas_chemshift.min,
				requestArrayEncoding: "float64-hex", // flag to binary encode values
			};
		}
		if (this.name == "JgraphObject") {
			// Specify here the version number of the specific object (needed to allow version update)
			this.versionDataFromReader = 1;
			if (!dataInput.jsonSpectrum) {
				console.error("No jsonSpectrum in dataInput", dataInput);
				this.data = {};
				return;
			}
			if (!dataInput.jsonMolecule) {
				console.error("No jsonMolecule in dataInput", dataInput);
				this.data = {};
				return;
			}
			if (!dataInput.jsonDataInitial) {
				console.error("No jsonDataInitial in dataInput", dataInput);
				this.data = {};
				return;
			}

			const jsonSpectrum = dataInput.jsonSpectrum;
			const jsonMolecule = dataInput.jsonMolecule;
			const jsonDataInitial = dataInput.jsonDataInitial;

			const fieldsToKeepMolecule = [
				"$mnova_schema",
				"assignments",
				"predictions",
				"parameters",
				"bonds",
				"atoms",
			];

			const allObjectsExtractedMolecule = processMnovaJsonMolecule(
				jsonMolecule,
				"molecule",
				fieldsToKeepMolecule
			);

			if (typeof allObjectsExtractedMolecule === "undefined") {
				console.error(
					"allObjectsExtractedMolecule",
					allObjectsExtractedMolecule
				);
				console.error("fileNameData", fileNameData);
			}

			const fieldsToKeepSpectrum = [
				"data",
				"raw_data",
				"multiplets",
				"peaks",
				"processing",
				"parameters",
				"$mnova_schema",
			];

			const allSpectraObjectsExtracted = processMnovaJsonSpectrum(
				jsonSpectrum,
				"spectra",
				fieldsToKeepSpectrum
			);
			const storeAll = false;
			var spectrumDataAll = [];
			if (storeAll) {
				for (var i = 0; i < allSpectraObjectsExtracted.length; i++) {
					for (var i2 = 0; i2 < allSpectraObjectsExtracted[i].length; i2++) {
						spectrumDataAll.push(
							extractSpectrumData(allSpectraObjectsExtracted[i][i2], "data")
						);
					}
				}
			} else {
				// First the reference spectrum
				const spectrumData = extractSpectrumData(
					allSpectraObjectsExtracted[0][0],
					"data"
				);
				// Add from all other spectra only the last one
				spectrumDataAll.push(spectrumData);
				for (var i = 0; i < allSpectraObjectsExtracted.length; i++) {
					const lastItem = allSpectraObjectsExtracted[i].length - 1;
					spectrumDataAll.push(
						extractSpectrumData(allSpectraObjectsExtracted[i][lastItem], "data")
					);
				}
			}

			if (false) {
				// demo creation spectrum
				spectrumDataAll.push([
					{ chemShift: 7.305, value: 10000 },
					{ chemShift: 7.3, value: 3000000 },
					{ chemShift: 7.295, value: 10000 },
					{ chemShift: 7.29, value: 80000 },
				]);
			}

			const marginPPM = 0.02;
			const minSpaceBetweenRegions = 0.05;
			const regionsData = getRegionsWithSignal(
				spectrumDataAll[0],
				minSpaceBetweenRegions,
				marginPPM
			);

			console.log("TTPo spectrumDataAll", spectrumDataAll);
			console.log("TTPo regionsData", regionsData);
			const spectrumDataAllChopped = filterOutPointsOutsideRegions(
				spectrumDataAll,
				regionsData
			);
			//const spectrumDataAllChopped = (spectrumDataAll);
			console.log("TTPo spectrumDataAllChopped", spectrumDataAllChopped);

			var jGraphObjDataList = [];

			//if (fileResulstSF !== "") {
			//	const tmp11 = await readFile(fileResulstSF, "utf-8");
			//	const jsonDataInitial = JSON.parse(tmp11);
			if (jsonDataInitial && Object.keys(jsonDataInitial).length > 0) {
				const obj3 = processSf(jsonDataInitial, "variableSet");
				if (obj3) {
					if (obj3.data) {
						if (obj3.data.length > 0) {
							obj3.originScript = "variableSet using processSf";
							jGraphObjDataList.push(obj3);
						}
					}
				}

				const obj2 = processSf(jsonDataInitial, "couplingNetwork");
				console.log("jGraphObjZ 2 ", obj2);
				if (obj2) {
					if (obj2.data) {
						if (obj2.data.length > 0) {
							obj2.originScript = "couplingNetwork using processSf";
							jGraphObjDataList.push(obj2);
						}
					}
				}
			}

			if ("assignments" in allObjectsExtractedMolecule) {
				const obj = ingestMoleculeObject(
					allObjectsExtractedMolecule,
					allSpectraObjectsExtracted[0][0].multiplets
				);

				obj.originScript = "assignments using ingestMoleculeObject";
				jGraphObjDataList.push(obj);
			}

			// this is not done or finished....
			if ("assignments" in allObjectsExtractedMolecule) {
				const obj = ingestSpectrumRegions(
					allObjectsExtractedMolecule,
					allSpectraObjectsExtracted[0][0].multiplets
				);

				obj.originScript = "assignments using ingestSpectrumRegions";
				jGraphObjDataList.push(obj);
			}

			this.data = {
				jGraphObjDataList: jGraphObjDataList,
				allObjectsExtractedMolecule: allObjectsExtractedMolecule,
				spectrumDataAllChopped: spectrumDataAllChopped,
				regionsData: regionsData,

				//requestArrayEncoding: "float64-hex", // flag to binary encode values
			};
		}
	}

}
