// AUTOMATIC IMPORT INSERTION WILL BE MADE HERE
// include for bridge from solidStateNMRCSA-reader
import { csa2xyNMR } from "./csa2xyNMR.js";


import { ObjectBase } from "./objectBase.js";

export class NMRspinSystemModel_CSA extends ObjectBase {
	constructor(param, input) {
		super(param, input, "NMRspinSystemModel_CSA");
		// optionally override again
		this.verbose = 0;
	}

	_handleLoadDemoData(input) {
		this._loadDemoData(input);
	}

	_loadDemoData(input) {
	}

// AUTOMATIC METHOD INSERTION WILL BE MADE HERE
 bridge_Editordjeanner_Version1_SourceNMRspinSystemModel_CSA_IDnone(
	param
) {
	const name = "bridge_Editordjeanner_Version1_SourceNMRspinSystemModel_CSA_IDnone";
	const obj = this.data;
	const objDataField = param.objDataField;
	const objectObj = param.objectObj;
	const objSource = param.object;
	const newFields = param.newFields;

	if (!objSource) {
		console.error(
			`No objSource string in param. Error generated by ${name} param : `,
			param
		);
		return {};
	}
	if (objSource === "nmrSpectrumObject") {
		// no implementation of version of input and output objects

		//Naive building
		console.log("bridge solidStateNMRCSA param:", param);
		console.log("bridge solidStateNMRCSA this:", this);
		var valuesCSA = [];
		valuesCSA.push(this.data.spins[0].diagTensorValues.xx);
		valuesCSA.push(this.data.spins[0].diagTensorValues.yy);
		valuesCSA.push(this.data.spins[0].diagTensorValues.zz);
				console.log("bridge solidStateNMRCSA valuesCSA:", valuesCSA);

		// main call to conveter
		const ret_csa2xyNMR = csa2xyNMR(valuesCSA);
		const { x, y, iso, sAni, eta, mi, ma, integral, source } = ret_csa2xyNMR;

		if (this.verbose) {
			console.log(" zz :", zz, " yy :", yy, " xx :", xx);
			console.log(" sAni :", sAni);
			console.log("eta :", eta);
			console.log("sAni :", sAni);
			console.log("vvinit :", iso);
			console.log("vvmax :", Math.sqrt(xx * xx + yy * yy + zz * zz));
		}

		// Naive origin building
		var origin = {
			comment_origin:
				`generated by ${name}`,
		};
		origin["technical_source"] = source;
		origin["origin"] = param.origin; // inheritage
		// add time ?...

		// main data generation
		const p0 = x[0] / newFields.frequency
		const pn = x[x.length - 1] / newFields.frequency
		const firstPoint = Math.max(p0, pn);
		const lastPoint = Math.min(p0, pn);
		const values = p0 < pn ? [...y] : [...y].reverse();

		// create content of output
		const output = {firstPoint, lastPoint, values, origin, ...newFields};

		return output;
	}
	console.error(
		`objSource : ${objSource} not implemented from ${name}`
	);
	return {};
}


}
